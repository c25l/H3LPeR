/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CalendarAgendaPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// agenda-utils.ts
function filterAgendaEventsFromCalendar(events) {
  const normalized = events.map((event) => {
    const summary = cleanAgendaSummary(event.summary || event.title || "Untitled");
    const availability = getAgendaAvailability(event, summary);
    const start = event.start || null;
    const end = event.end || event.start || null;
    const startMs = start ? new Date(start).getTime() : NaN;
    const endMs = end ? new Date(end).getTime() : startMs;
    return {
      summary,
      start,
      end,
      location: event.location,
      allDay: !!event.allDay,
      availability,
      _startMs: startMs,
      _endMs: endMs
    };
  });
  const filtered = normalized.filter((event) => !["free", "tentative"].includes(event.availability));
  const meetingTimes = new Set(
    filtered.filter((event) => event.summary.trim().toLowerCase() === "meeting").map((event) => `${event._startMs}-${event._endMs}`)
  );
  return filtered.filter((event) => !(event.availability === "busy" && meetingTimes.has(`${event._startMs}-${event._endMs}`))).sort((a, b) => a._startMs - b._startMs).map(({ _startMs, _endMs, availability, ...rest }) => rest);
}
function getAgendaAvailability(event, summary) {
  if (event.availability)
    return String(event.availability).toLowerCase();
  if (event.transparency) {
    const transparency = String(event.transparency).toLowerCase();
    if (transparency === "transparent")
      return "free";
    if (transparency === "opaque")
      return "busy";
  }
  const text = `${summary || ""} ${event.description || ""}`;
  const match = text.match(/\b(Free|Busy|Tentative)\b/i);
  return match ? match[1].toLowerCase() : "busy";
}
function cleanAgendaSummary(text) {
  return String(text || "Untitled").replace(/\(\s*(Free|Busy|Tentative)\s*\)/gi, "").replace(/\b(Free|Busy|Tentative)\b/gi, "").replace(/\s{2,}/g, " ").replace(/^[-–—]\s*/, "").trim() || "Untitled";
}
function buildAgendaMarkdown(events) {
  const lines = ["## Agenda", ""];
  events.forEach((event) => {
    var _a;
    let timeLabel = "";
    if (event.allDay) {
      timeLabel = "All day";
    } else if (event.start) {
      const startDate = new Date(event.start);
      timeLabel = startDate.toLocaleTimeString("en-US", { hour: "numeric", minute: "2-digit" });
    }
    const summaryText = ((_a = event.summary) == null ? void 0 : _a.trim().toLowerCase()) === "meeting" ? "#work" : event.summary || "Untitled";
    let line = `- **${timeLabel}** ${summaryText}`;
    if (event.location) {
      line += ` _(${event.location})_`;
    }
    lines.push(line);
  });
  lines.push("");
  return lines.join("\n");
}

// main.ts
var CalendarAgendaPlugin = class extends import_obsidian.Plugin {
  async onload() {
    this.addCommand({
      id: "insert-agenda-clipboard",
      name: "Insert agenda from clipboard (JSON)",
      editorCallback: async (editor, view) => {
        try {
          const clipboardText = await navigator.clipboard.readText();
          const events = JSON.parse(clipboardText);
          if (!Array.isArray(events)) {
            new import_obsidian.Notice("Clipboard content must be a JSON array of events");
            return;
          }
          this.insertAgenda(editor, events);
        } catch (error) {
          console.error("Failed to parse clipboard:", error);
          new import_obsidian.Notice("Failed to parse clipboard content as JSON");
        }
      }
    });
  }
  onunload() {
  }
  /**
   * Insert agenda at cursor position (read-only display)
   */
  insertAgenda(editor, events) {
    const agendaEvents = filterAgendaEventsFromCalendar(events);
    if (agendaEvents.length === 0) {
      new import_obsidian.Notice("No events to display");
      return;
    }
    const agendaText = buildAgendaMarkdown(agendaEvents);
    editor.replaceSelection(agendaText);
    new import_obsidian.Notice(`Displayed ${agendaEvents.length} event(s)`);
  }
};
